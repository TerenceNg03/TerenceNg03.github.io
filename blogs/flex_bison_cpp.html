<!DOCTYPE HTML>

<html>
    <head>
        <title>
             Flex &amp; Bison Cpp Tutorial
        </title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/common/common.css">
        <link rel="apple-touch-icon" sizes="180x180" href="../favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon/favicon-16x16.png">
        <link rel="manifest" href="../favicon/site.webmanifest">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js">
            
        </script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../css/blogs.css">
        <link rel="stylesheet" href="../data/blogs/highlight/styles/default.min.css">
        <script src="../data/blogs/highlight/highlight.min.js">
            
        </script>
        <script src="../data/blogs/highlight/languages/haskell.min.js">
            
        </script>
        <script src="../data/blogs/catalog.js" defer="">
            
        </script>
    </head>
    <body>
        <div class="head-title">
            <div class="logo-ani">
                Terence Ng
            </div>
            <div class="cata">
                <span class="head-split">
                    |
                </span>
                <span class="head-part">
                    Blogs
                </span>
            </div>
        </div>
        <div class="navbar-container">
            <script>
                function autoScrollTo(el) {    var top = $("#" + el).offset().top;    $("html, body").animate({ scrollTop: top }, 1000);    }
            </script>
            <div class="navbar">
                <a href="../index.html">
                    Home
                </a>
                <a href="../blogs/index.html">
                    Blogs
                </a>
                <a href="../photos/index.html">
                    Photos
                </a>
                <a href="../poems/index.html">
                    Poems
                </a>
                <a href="../proses/index.html">
                    Proses
                </a>
                <a href="#" onclick="return false;" onmousedown="autoScrollTo(&#39;About&#39;);">
                    About
                </a>
            </div>
        </div>
        <div class="blog-container">
            <h1>Flex &amp; Bison Cpp Tutorial</h1>
<h2>What is Flex &amp; Bison ?</h2>
<p>Flex &amp; Bison are a set of tools developed by GNU that are used to generate a parser that can deal with structured input. Flex is a tokenizer that divided input character stream into tokens. These tokens are then sent to Bison which will match them against specific grammar rules and perform actions accordingly.</p>
<h2>Flex &amp; Bison and c++</h2>
<p>Flex &amp; Bison have been around for more than 40 years. When they first born, there is even no cpp. So at first they only generate parser in c which includes lot of global variables and usually can not be reused. Unfortunately, today even they are officially support cpp, most of the tutorial is still using c code. And that is why I want to do this tutorial to assist you switch to cpp. Here I suppose you have master the basic usage and if you are not you may refer to <a href="http://www.capsl.udel.edu/courses/cpeg421/2012/slides/Tutorial-Flex_Bison.pdf">this article</a>.</p>
<h2>Setup Driver</h2>
<p>The outline of our parser will be like this.<br />
<strong>Note: All of the codes are available at the end of this article.</strong></p>
<pre><code class="language-cpp">class Driver
{
public:
    Driver();
    ~Driver();

    int parse();
    int parse_file(std::string&amp; path);

private:
    Scanner*    scanner; //Generated by Flex
    Parser*        parser;  //Generated by Bison
    location*    location;//Used to track errors
};
</code></pre>
<h2>Setup Scanner</h2>
<p>In this part, we will set up out flex file named <code>scanner.l</code>.</p>
<pre><code class="language-cpp">%option nodefault
%option debug
%option noyywrap
%option prefix=&quot;MyParser&quot;
%option yylineno
%option c++
</code></pre>
<p>First, we need to put the above options into our flex file. Their meanings are as following:</p>
<ul>
<li><code>nodefault</code>: Let flex do not generate default token.</li>
<li><code>debug</code>: Enable debug infomation.</li>
<li><code>noyywrap</code>: Flex will continue even if an EOF is read.</li>
<li><code>prefix</code>: Specific namespace of generated lexer.</li>
<li><code>yylineno</code>: Count line number.</li>
<li><code>c++</code>: Ask flex to generate c++ lexer.</li>
</ul>
<p>After this, we can defined our rules like this.</p>
<pre><code class="language-cpp">[0-9]{1,} return MyParser::Parser::make_NUM(atoi(yytext),loc);
&quot;-&quot; return MyParser::Parser::make_MINUS(loc);
&quot;+&quot; return MyParser::Parser::make_PLUS(loc);
\n return MyParser::Parser::make_NEWLINE(loc);
[ \t]+ /* ignore whitespace */
. return MyParser::Parser::make_ILLEGAL(std::string(yytext),loc);
</code></pre>
<h2>Setup Parser</h2>
<p>These options need to be put into <code>parser.y</code>.</p>
<pre><code class="language-plaintext">%locations
%define api.namespace {MyParser}
%define api.parser.class {Parser}
%lex-param {MyParser::Driver &amp;driver}
%parse-param {MyParser::Driver &amp;driver}
%define parse.error verbose
%language &quot;c++&quot;
%define api.value.type variant
%define api.token.constructor
</code></pre>
<p>Their meanings are as following:</p>
<ul>
<li><code>location</code>: Enable location tracking.</li>
<li><code>parse.error verbose</code>: Let bison generate detailed error messages.</li>
<li><code>parse-param</code>: Parameters passed to yyparse.</li>
<li><code>lex-param</code>: Parameters passed to yylex.</li>
<li><code>language</code>: Enable location tracking.</li>
<li><code>variant</code>: Use cpp variant feature instead of c style union.</li>
<li><code>constructor</code>: Generate constructor like <code>make_PLUS</code> we have used in <code>scanner.l</code>.</li>
</ul>
<p>Then we can add tokens and typed.</p>
<pre><code class="language-plaintext">%token NEWLINE PLUS MINUS 
%token  NUM 
%token END
%token  ILLEGAL
%type  EXPR    
</code></pre>
<p>We may return value type for each grammer. Note that token type must match the rules specificed by <code>scanner.l</code>.</p>
<h2>Error Detection and Recovery</h2>
<p>In order to read input line by line so that we can properly display error message. We need to reload <code>LexerInput</code>.</p>
<pre><code class="language-cpp">virtual size_t LexerInput( char* buf, size_t max_size );
</code></pre>
<p>And also update laoction when a token is read or a newline arrives.</p>
<pre><code class="language-cpp">/* scanner.l */
#define YY_USER_ACTION \
{loc.columns(yyleng); \
driver.scanner-&gt;current_col = \
    driver.scanner-&gt;current_col_end; \
driver.scanner-&gt;current_col_end += yyleng;}

/* parser.y */
STATEMENT : 
{  
    printf(&quot;Enter expression:&quot;);
}
| STATEMENT EXPR NEWLINE
{
    printf(&quot;The result is %f\n&quot;,$2);
    printf(&quot;Enter expression:&quot;);
    driver.location-&gt;lines();
    driver.location-&gt;step();
    driver.scanner-&gt;reset_current_col();
}
</code></pre>
<p>Now we have our location tracked and every line of input buffered. When an error occur, Bison will call <code>Parser::error()</code> and stop parsing. To prevent this from happening, we can utilize a special rule <code>error</code> which will match all unrecognized tokens.</p>
<pre><code class="language-cpp">/* Error display */
void Parser::error
    (const location&amp; loc, const std::string&amp; m)
{
    size_t current_col 
        = driver.scanner-&gt;current_col;
    std::cout&lt;&lt; &quot;line &quot; &lt;&lt;loc&lt;&lt; &quot;: &quot; &lt;&lt;m&lt;&lt; &quot;\n&quot;;
    fprintf(stderr,&quot;\t%s\t&quot;,
        driver.scanner-&gt;current_line.c_str());
    for(int i = 0; i &lt; current_col; i++)
        fprintf(stderr,&quot;~&quot;);
    fprintf(stderr,&quot;^\n&quot;);
    }

/* Error recovery */
| STATEMENT error NEWLINE
{
    driver.location-&gt;lines();
    driver.location-&gt;step();
    driver.scanner-&gt;reset_current_col();
    printf(&quot;Enter expression:&quot;);
}
</code></pre>
<p>The error message will be like this.</p>
<pre><code class="language-plaintext">Enter expression:12+6-0&amp;+66
line 1.1-7: syntax error, unexpected ILLEGAL, expecting NEWLINE
    12+6-0&amp;+66
    ~~~~~~^
Enter expression:
</code></pre>
<h2>Code Download</h2>
<p>For more details and complete codes, you may want to check my github repository <a href="https://github.com/TerenceNg03/Flex-Bison-Full-Cpp-Example">here</a>.</p>

        </div>
        <div class="footer-container">
            <div class="footer">
                <div class="quote">
                    <p>
                        永遠太遠 · 無謂太早 · 分對或錯
                    </p>
                </div>
                <div class="footer-inner" id="About">
                    <div class="copyright">
                        Original Photos &amp; Contents
                    </div>
                    <div class="copyright">
                        Copyright ©2021-2023 TerenceNg  All Rights Reserved.
                    </div>
                </div>
                <div class="contact-me">
                    <a href="https://github.com/TerenceNg03">
                        Github Profile
                    </a>
                    |
                    <a href="stoicism03@gmail.com">
                        Contact Me
                    </a>
                </div>
            </div>
        </div>
    </body>
</html>
