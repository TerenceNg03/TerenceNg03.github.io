<!DOCTYPE HTML>

<html>
    <head>
        <title>
             C++的函數式特性
        </title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/common/common.css">
        <link rel="apple-touch-icon" sizes="180x180" href="../favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon/favicon-16x16.png">
        <link rel="manifest" href="../favicon/site.webmanifest">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js">
            
        </script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../css/blogs.css">
        <link rel="stylesheet" href="../data/blogs/highlight/styles/default.min.css">
        <script src="../data/blogs/highlight/highlight.min.js">
            
        </script>
        <script src="../data/blogs/highlight/languages/haskell.min.js">
            
        </script>
        <script src="../data/blogs/catalog.js" defer="">
            
        </script>
    </head>
    <body>
        <div class="head-title">
            <div class="logo-ani">
                Terence Ng
            </div>
            <div class="cata">
                <span class="head-split">
                    |
                </span>
                <span class="head-part">
                    Blogs
                </span>
            </div>
        </div>
        <div class="navbar-container">
            <script>
                function autoScrollTo(el) {    var top = $("#" + el).offset().top;    $("html, body").animate({ scrollTop: top }, 1000);    }
            </script>
            <div class="navbar">
                <a href="../index.html">
                    Home
                </a>
                <a href="../blogs/index.html">
                    Blogs
                </a>
                <a href="../photos/index.html">
                    Photos
                </a>
                <a href="../poems/index.html">
                    Poems
                </a>
                <a href="../proses/index.html">
                    Proses
                </a>
                <a href="#" onclick="return false;" onmousedown="autoScrollTo(&#39;About&#39;);">
                    About
                </a>
            </div>
        </div>
        <div class="blog-container">
            <h1>C++的函數式特性</h1>
<h2>什麼是函數式編程？</h2>
<p>函數式編程是一種編程範式，就像面向對象編程（OOP）一樣。在函數式編程中，我們專注於函數。函數可以是另一個函數的參數或返回值。有關更多信息，請參見<a href="https://en.wikipedia.org/wiki/Functional_programming">維基百科</a>。</p>
<h2>Lambda 表達式</h2>
<p>Lambda 表達式，也稱為匿名函數，是一種特殊類型的函數，它沒有名稱。當需要臨時函數時，它特別有用。如果您曾經使用過 Python，您可能熟悉以下 Python 代碼。</p>
<pre><code class="language-python">lambda x: x if x&gt;=0 else -x
</code></pre>
<p>這行代碼返回輸入變量 x 的絕對值。自從 C++11 以來，我們也可以這樣做。</p>
<pre><code class="language-cpp">[=](double x)-&gt;int{return x&gt;=0? x:-x ;};
</code></pre>
<h3>Lambda 表達式的語法</h3>
<p>現在讓我們分析一下這行代碼的含義。</p>
<p>[=] 表示這個 lambda 捕獲所有外部變量的值。<strong>請注意，默認情況下，所有被值捕獲的變量都是不可變的。</strong> 所有可能的值包括：</p>
<ul>
<li><code>[ ]</code>：不捕獲任何變量。</li>
<li><code>[=]</code>：通過值捕獲所有變量。</li>
<li><code>[&amp;]</code>：通過引用捕獲所有變量。</li>
<li><code>[=,&amp;y]</code>：通過引用捕獲 <code>y</code>，其它所有變量通過值捕獲。</li>
<li><code>[&amp;,x]</code>：通過值捕獲 <code>x</code>，其它所有變量通過引用捕獲。</li>
<li><code>[&amp;x,y]</code>：指定如何捕獲 <code>x</code> 和 <code>y</code>。不允許捕獲其他變量。</li>
</ul>
<p><code>(double)</code> 是應該傳遞給此 lambda 表達式的參數列表。<strong>在 C++14 中，auto 關鍵字在此處也是允許的，這使得 lambda 函數具備了執行鴨子類型的能力。</strong></p>
<p><code>-&gt;int</code> 指定此函數的返回類型為 <code>int</code>。<strong>請注意，這不是自願的。如果聲明瞭函數，則必須返回 int。</strong> 還允許其他一些選項。包括返回類型在內的所有選項都可以省略。</p>
<ul>
<li><code>mutable</code>: 允許修改被值捕獲的變量。</li>
<li><code>noexcept</code>: 與普通函數使用方式相同。</li>
<li><code>throw()</code>: 與普通函數使用方式相同。</li>
<li><code>-&gt;int</code>: 特定返回類型。</li>
</ul>
<h3>Lambda 表達式的使用</h3>
<p>對於 lambda 表達式，它可以被存儲在變量或 <code>std::function</code> 中。或者它可以被立即調用，或直接傳遞給接受它作為參數的函數，例如 <code>std::sort</code>。</p>
<pre><code class="language-cpp">/* 存儲在一個 auto 變量中 */
auto lambda1 = [](double x){return x&gt;=0? 1:-1 ;};
/* 構建 std::function */
std::function lambda = 
    [](int x) { return x&gt;=0? 1:-1 ; };
/* 直接調用 */
int i = [](double x){return x&gt;=0? 1:-1 ;}(9);
/* 作為參數傳遞給函數 */
std::sort(v.begin(), v.end(), 
    [](auto x, auto y){return x&gt;y;});
</code></pre>
<h2>Lambda 表達式作為參數傳遞</h2>
<p>在這裡，你有兩個選擇。你可以使用 <code>std::function</code> 或使用一個模板。</p>
<pre><code class="language-cpp">/* std::function 解決方案 */
void f_(std::function lambda)
    {/* ... */};
/* 模板 */
template
void f(F lambda) { /* ... */}
</code></pre>
<h2>遞歸的 Lambda Expression</h2>
<p>通過將 lambda 表達式分配給 <code>std::function</code>，可以引用它本身。<strong>請注意，函數必須被引用捕獲。否則它將被編譯，但會產生運行時錯誤。</strong></p>
<pre><code class="language-cpp">std::function factorial = [=] (int i)
    {
        return (i == 1) ? 1 : i * factorial(i - 1);
    };
</code></pre>
<h2>什麼是 std::function？</h2>
<p>根據 <a href="https://en.cppreference.com/w/cpp/utility/functional/">cppreference</a> 的說法，<code>std::function</code> 實例可以存儲、複製和調用 <strong>任何可複製構造的可調用目標</strong>。這包括 lambda 表達式、函數指針，甚至是成員函數。這裡是一個使用 <code>std::function</code> 而不是傳統函數指針的例子。</p>
<pre><code class="language-cpp">int foo(){return 0;}
/* C 風格 */
int (*fp)(int) = foo;
/* std::function */
std::function func = foo;
</code></pre>
<h2>在 C++ 中創建回調</h2>
<p>如果你熟悉 Javascript，你可能已經知道回調的概念。</p>
<pre><code class="language-javascript">function Callback() {
    console.log(&quot;I am executed!&quot;);
}
Callback();
</code></pre>
<p>簡而言之，回調是作為參數傳遞給另一個函數的函數，直到回調被調用該函數才執行。在引入 <code>std::function</code> 之前，這是通過接口和抽象類實現的，有時可能是一個不乾淨的解決方案，會造成很多混亂。例如，我們可以創建一個類方法的回調，而不使用接口。</p>
<pre><code class="language-cpp">class executer{
public:
    int exec(std::function f){
        return f(1);
    }
};

int foo(int a){return a;}

class bar{
public:
    int run(int a){return a;}
};

int main(){
    executer e;
    bar s;
    e.exec(foo);
    using std::placeholders::_1;
    e.exec(std::bind(&amp;bar::run, &amp;s, _1));
}
</code></pre>
<p>在上面的例子中，如果不使用回調，我們仍然可以通過傳遞函數指針來運行 <code>foo</code>。然而，要執行 <code>bar::run</code>，我們將不得不繼承 <code>executer</code>，以便它將 <code>bar</code> 作為參數接受，因為非靜態成員函數無法被引用。</p>
<h2>std::bind 的用法</h2>
<p><code>std::bind</code> 的作用是綁定參數和函數以創建一個新的函數對象。它還可以僅綁定部分參數列表，甚至使用 <code>std::placeholders</code> 重新排序參數。</p>
<pre><code class="language-cpp">int foo(int a, int b){return a-b;}

class Bar{
public:
    int run(int a){return a;}
};

int main(){
    /* _1 _2 ... _N 來自這裡 */
    using namespace std::placeholders;
    /* foo(b, a) */
    auto f1 = std::bind(foo,_2,_1);
    /* foo(a, 3) */
    auto f2 = std::bind(foo,_1, 3);    
    /* foo(1, 3) */
    auto f3 = std::bind(foo, 1, 3);
    /* 返回 bar.run(a) */
    Bar b;
    auto f4 = std::bind(&amp;Bar::run, &amp;b, _1);
    /* 打印 1 0 -2 6 */
    printf(&quot;%d %d %d %d&quot;,
           f1(1,2), f2(3,1), f3(-1,-2, 5), f4(6));
}
</code></pre>
<p><code>std::bind</code> 接受佔位符和實際對象。如果它將佔位符綁定到函數，則必須在調用生成的函數時傳遞參數。任何其他參數都將被忽略。也可以將成員函數與實際的類對象綁定。</p>

        </div>
        <div class="footer-container">
            <div class="footer">
                <div class="quote">
                    <p>
                        永遠太遠 · 無謂太早 · 分對或錯
                    </p>
                </div>
                <div class="footer-inner" id="About">
                    <div class="copyright">
                        Original Photos &amp; Contents
                    </div>
                    <div class="copyright">
                        Copyright ©2021-2023 TerenceNg  All Rights Reserved.
                    </div>
                </div>
                <div class="contact-me">
                    <a href="https://github.com/TerenceNg03">
                        Github Profile
                    </a>
                    |
                    <a href="stoicism03@gmail.com">
                        Contact Me
                    </a>
                </div>
            </div>
        </div>
    </body>
</html>
