<!DOCTYPE HTML>

<html>
    <head>
        <title>
             Monad Transformers 簡介
        </title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/common/common.css">
        <link rel="apple-touch-icon" sizes="180x180" href="../favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon/favicon-16x16.png">
        <link rel="manifest" href="../favicon/site.webmanifest">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js">
            
        </script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../css/blogs.css">
        <link rel="stylesheet" href="../data/blogs/highlight/styles/default.min.css">
        <script src="../data/blogs/highlight/highlight.min.js">
            
        </script>
        <script src="../data/blogs/highlight/languages/haskell.min.js">
            
        </script>
        <script src="../data/blogs/catalog.js" defer="">
            
        </script>
    </head>
    <body>
        <div class="head-title">
            <div class="logo-ani">
                Terence Ng
            </div>
            <div class="cata">
                <span class="head-split">
                    |
                </span>
                <span class="head-part">
                    Blogs
                </span>
            </div>
        </div>
        <div class="navbar-container">
            <script>
                function autoScrollTo(el) {    var top = $("#" + el).offset().top;    $("html, body").animate({ scrollTop: top }, 1000);    }
            </script>
            <div class="navbar">
                <a href="../index.html">
                    Home
                </a>
                <a href="../blogs/index.html">
                    Blogs
                </a>
                <a href="../photos/index.html">
                    Photos
                </a>
                <a href="../poems/index.html">
                    Poems
                </a>
                <a href="../proses/index.html">
                    Proses
                </a>
                <a href="#" onclick="return false;" onmousedown="autoScrollTo(&#39;About&#39;);">
                    About
                </a>
            </div>
        </div>
        <div class="blog-container">
            <h1>Monad Transformers 簡介</h1>
<p>在我們開始之前，我想用一個例子來說明為什麼我們需要引入 monad transformer 以及它試圖解決什麼問題。</p>
<h2>Monad Stack</h2>
<p>有時我們有一些基本的 monad，比如 <code>IO</code>，<code>Maybe</code> 和 <code>State</code>。每個 monad 都處理自己的事情。但是，如果我想在 <code>State</code> monad 中返回可能不存在的東西，該怎麼辦？直覺上，我們會寫出這樣的代碼。</p>
<pre><code class="language-haskell">run :: State (Maybe String) Int
run = do
    s1 &lt;- get
    case s1 of
        Nothing -&gt; ...
        Just x -&gt; do
            put $ Just &quot;abcde&quot;
            s2 &lt;- get
            case s2 of
                Nothing -&gt; ...
                Just x' -&gt; ...
</code></pre>
<p>但問題是每次我們嘗試獲取狀態時，都必須進行模式匹配。這段代碼是純粹的樣板代碼，因為我們已經有了 <code>Maybe</code> monad 來只在有東西時繼續計算。我們想要的是一些可以將不同 monad 的能力結合在一起的東西。這就是我今天要談論的 monad transformer。</p>
<h2>Monad Transformer 是什麼</h2>
<p>Monad Transformer 是一個同時是 <code>Monad</code> 和 <code>MonadTrans</code> 類的東西。讓我們先看一下它們的類型簽名。</p>
<pre><code class="language-haskell">class Applicative m =&gt; Monad m where
    return :: a -&gt; m a
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b

class MonadTrans (t :: (* -&gt; *) -&gt; * -&gt; *) where
    lift :: Monad m =&gt; m a -&gt; t m a
</code></pre>
<p>你可能會看到 <code>MonadTrans</code> 接受一個 <code>* -&gt; *</code> 和一個 <code>*</code>，然後給我們一個真正的 <code>Type</code>。它只有一個非常有趣的方法叫做 <code>lift</code>。它接受一個 monad <code>m</code>（對應於 <code>* -&gt; *</code>），然後將其包裝到自身（<code>t</code>）中，以便我們得到一個 <code>t m a</code>。</p>
<p>通常，一個 Monad Transformer 也是一個 monad。這意味著我們可以這樣做：</p>
<pre><code class="language-haskell">run = do 
    config &lt;- ask
    lift $ print config
</code></pre>
<p>這段代碼將 <code>Reader</code> 轉換為 <code>IO</code> monad，讓我們輕鬆地獲取 monad 中的內容。太棒了！</p>
<h2>實現 ReaderT</h2>
<p><code>ReaderT</code> 是一個非常簡單的 monad transformer。它接受一個<strong>只讀配置</strong>並沿著 monad 傳遞，同時允許您使用 <code>ask</code> 查詢配置。</p>
<pre><code class="language-haskell">import Control.Monad.Trans (MonadTrans, lift)

newtype ReaderT r m a = ReaderT {runReaderT :: r -&gt; m a}

instance Functor m =&gt; Functor (ReaderT r m) where
    fmap f rt = ReaderT $ fmap f . runReaderT rt

instance (Applicative m) =&gt; Applicative (ReaderT r m) where
    pure x = ReaderT $ const (pure x)
    f &lt;*&gt; rt = ReaderT $ 
        \r -&gt; runReaderT f r &lt;*&gt; runReaderT rt r

instance (Monad m) =&gt; Monad (ReaderT r m) where
    return = pure
    rt &gt;&gt;= f = ReaderT $
        \r -&gt; runReaderT rt r &gt;&gt;= (flip runReaderT r &lt;$&gt; f)

instance MonadTrans (ReaderT r) where
    lift m = ReaderT $ const m
</code></pre>
<p>我們需要實現一些東西來獲取我們的 <code>r</code>。</p>
<pre><code class="language-haskell">ask :: (Monad m) =&gt; ReaderT r m r
ask = ReaderT return
</code></pre>
<p>有時我們只想使用單個 <code>Reader</code>，因此讓我們將 <code>Reader</code> 作為類型別名，將 <code>ReaderT</code> 應用於 <code>Identity</code> monad。</p>
<pre><code class="language-haskell">import Control.Monad.Identity (Identity)
type Reader r = ReaderT r Identity
</code></pre>
<h2>使用 ReaderT</h2>
<p>現在我們已經定義了 <code>ReaderT</code>，是時候試驗一下它了。</p>
<pre><code class="language-haskell">run :: ReaderT Int (State String) ()
run = do
    lift $ put &quot;Hello&quot;
    config &lt;- ask
    case config of
        0 -&gt; return ()
        n -&gt; lift $ modify (++ replicate n 'a')
</code></pre>
<p>正如你所看到的，我們可以在 do 表達式塊中任何地方讀取我們的配置。但代價是我們必須在其他所有地方都放置一個 lift，這幾乎使我們的 <code>ReaderT</code> 不可用。有沒有辦法改進這一點呢？</p>
<h2>MonadX 類</h2>
<p>最明顯的解決方案是給 <code>lift put</code> 做一個別名。</p>
<pre><code class="language-haskell">putLifted = lift put
putLiftedLifted = lift putLifted
putLiftedLiftedLifted = lift putLiftedLifted
</code></pre>
<p>相當繁瑣，對吧？</p>
<p>讓我們看看 <code>put</code> 究竟是什麼。</p>
<pre><code class="language-haskell">class Monad m =&gt; MonadState s m | m -&gt; s where
    -- | Replace the state inside the monad.
    put :: s -&gt; m ()
    ...
</code></pre>
<p>所以，<code>put</code> 實際上是類 <code>MonadState</code> 的一個方法，可以返回任何 <code>m ()</code> 類型的單子。為了使 <code>put</code> 返回我們想要的內容，我們應該使任何被 <code>ReaderT</code> 包裝的 <code>MonadState</code> 也成為 <code>MonadState</code> 的一個實例。</p>
<pre><code class="language-haskell">{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}

instance MonadState s m =&gt; MonadState s (ReaderT r m) where
    get = lift get
    put s = lift $ put s

run' :: ReaderT Int (State String) ()
run' = do
    put &quot;Hello&quot;
    config &lt;- ask
    case config of
        0 -&gt; return ()
        n -&gt; modify (++ replicate n 'a')
</code></pre>
<p>在我們繼續編寫 <code>ReaderT</code> 的 <code>MonadReader</code> 之前，我想簡要解釋一下類定義中的 <code>| m -&gt; s</code> 是什麼意思。</p>
<p>在 Haskell 中，<code>m -&gt; s</code> 被稱為 <strong>函數依賴（functional dependency）</strong>。它告訴 <code>ghc</code>，如果有一個 <code>m</code>，那麼就有且僅有一個 <code>s</code> 使得 <code>MonadState s m</code> 成為一個有效的實例。因此，一旦 <code>ghc</code> 知道了 <code>m</code> 是什麼，它就不會嘗試推斷 <code>s</code> 是什麼。這就像告訴 <code>ghc</code>，我有一個引理表明 <code>m -&gt; s</code>，然後當它檢查你的類型時，<code>ghc</code> 將嘗試證明並使用這個引理。否則，在某些情況下，當 <code>s</code> 無法推斷出來時，<code>ghc</code> 將簡單地拋出一個錯誤，表示它不知道 <code>s</code> 是什麼。</p>
<p>好了，理論夠了，我們來寫代碼吧。我們需要將我們的 <code>ask</code> 移入 <code>MonadReader</code> 中，這樣如果有人使用 <code>EitherT String (Reader String) ()</code>，他們也不需要 <code>lift ask</code>這種代碼了。</p>
<pre><code class="language-haskell">{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleInstances #-}

class Monad m =&gt; MonadReader r m | m -&gt; r where
    ask :: m r
    ask = reader id

    reader :: (r -&gt; a) -&gt; m a
    reader f = ask &gt;&gt;= \r -&gt; return (f r)

-- 將 `ReaderT` 變為 `MonadReader` 的實例
instance Monad m =&gt; MonadReader r (ReaderT r m)
    ask = ReaderT return
</code></pre>
<p>對於我們想要堆疊在 <code>ReaderT</code> 上的任何單子變換器，我們只需要將其變為 <code>MonadReader</code> 的一個實例。然後 <code>ghc</code> 就會自動為我們 <code>lift</code> 它們。</p>

        </div>
        <div class="footer-container">
            <div class="footer">
                <div class="quote">
                    <p>
                        永遠太遠 · 無謂太早 · 分對或錯
                    </p>
                </div>
                <div class="footer-inner" id="About">
                    <div class="copyright">
                        Original Photos &amp; Contents
                    </div>
                    <div class="copyright">
                        Copyright ©2021-2023 TerenceNg  All Rights Reserved.
                    </div>
                </div>
                <div class="contact-me">
                    <a href="https://github.com/TerenceNg03">
                        Github Profile
                    </a>
                    |
                    <a href="stoicism03@gmail.com">
                        Contact Me
                    </a>
                </div>
            </div>
        </div>
    </body>
</html>
