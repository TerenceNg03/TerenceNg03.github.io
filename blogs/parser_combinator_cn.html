<!DOCTYPE HTML>

<html>
    <head>
        <title>
             來寫一個Parser Combinator
        </title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../css/common/common.css">
        <link rel="apple-touch-icon" sizes="180x180" href="../favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon/favicon-16x16.png">
        <link rel="manifest" href="../favicon/site.webmanifest">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js">
            
        </script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../css/blogs.css">
        <link rel="stylesheet" href="../data/blogs/highlight/styles/default.min.css">
        <script src="../data/blogs/highlight/highlight.min.js">
            
        </script>
        <script src="../data/blogs/highlight/languages/haskell.min.js">
            
        </script>
        <script src="../data/blogs/catalog.js" defer="">
            
        </script>
    </head>
    <body>
        <div class="head-title">
            <div class="logo-ani">
                Terence Ng
            </div>
            <div class="cata">
                <span class="head-split">
                    |
                </span>
                <span class="head-part">
                    Blogs
                </span>
            </div>
        </div>
        <div class="navbar-container">
            <script>
                function autoScrollTo(el) {    var top = $("#" + el).offset().top;    $("html, body").animate({ scrollTop: top }, 1000);    }
            </script>
            <div class="navbar">
                <a href="../index.html">
                    Home
                </a>
                <a href="../blogs/index.html">
                    Blogs
                </a>
                <a href="../photos/index.html">
                    Photos
                </a>
                <a href="../poems/index.html">
                    Poems
                </a>
                <a href="../proses/index.html">
                    Proses
                </a>
                <a href="#" onclick="return false;" onmousedown="autoScrollTo(&#39;About&#39;);">
                    About
                </a>
            </div>
        </div>
        <div class="blog-container">
            <h1>來寫一個Parser Combinator</h1>
<p>在之前的文章中，我已經談到了使用 <code>flex &amp; bison</code> 生成解析器。然而，這樣的解析器已知存在一系列問題。首先是它們幾乎無法進行調試和測試。在實踐中，我們希望以小單位測試我們的解析器，從而可以精確定位錯誤。另一個常見問題是讓解析器生成器生成代碼會使編譯更加複雜（特別是對於像 <code>C++</code> 這樣的語言），用戶被迫學習它們自己的 API，這可能非常繁瑣。</p>
<h2>那麼，什麼是Parser Combinator？</h2>
<p>Parser Combinator是一個 <code>Monad</code>，同時也是 <code>Functor</code> 和 <code>Applicative</code> 的instance。它允許我們將小型和簡單的解析器組合成大型和複雜的解析器，並且不需要編寫任何語法/語法文件。例如，為了使用解析器組合器識別標識符，我們可以這樣做：</p>
<pre><code class="language-haskell">charP :: (Char -&gt; Bool) -&gt; Parser Char
charP = undefined -- detail omitted here

repeatP :: Parser a -&gt; Parser [a]
repeatP = undefined -- detail omitted here

identP :: Parser String
identP = liftA2 (:) startP $ repeatP bodyP
    where bodyP = charP $ not . isSpace
          startP = charP isLetter
</code></pre>
<h2>好的，告訴我怎麼做</h2>
<p>像大多數 <code>Monad</code> 一樣，讓我們從將 <code>Parser</code> 定義為 <strong>封裝的 lambda 函數</strong> 開始，它將 <code>String</code> 轉換為剩餘的字符串和解析的數據（類型為 <code>a</code>）的元組。</p>
<p>這裡我們將編寫一個簡單的，不做任何錯誤處理的<code>BaseParser</code>，之後再填加上相關的方法</p>
<pre><code class="language-haskell">newtype BaseParser a = BaseParser 
    {runBaseParser :: String -&gt; (String, a)}
</code></pre>
<p>現在讓我們將其變為 <code>Functor</code>。</p>
<pre><code class="language-haskell">instance Functor BaseParser where
    fmap f p = BaseParser $ \s -&gt;
        let (s', a) = runBaseParser p s
         in (s', f a)
</code></pre>
<p>由於<code>Functor</code>的特性，現在我們能夠將 <code>BaseParser a</code> 轉換為 <code>BaseParser b</code>，但我們仍然無法組合兩個解析器，而這是解析上下文無關文法（CFG）所需的。這就是為什麼我們必須將其變為 <code>Applicative</code>。儘管 <code>Applicative</code> 足以處理任何上下文無關文法（CFG），但我們可能對更強大的內容感興趣，以便解析上下文敏感文法（CSG）。這要求我們將我們的 <code>Parser</code> 變成一個 <code>Monad</code>。</p>
<pre><code class="language-haskell">{-# LANGUAGE TupleSections #-}
import Control.Monad (ap)

instance Applicative BaseParser where
    pure a = BaseParser (,a)
    (&lt;*&gt;) = ap

instance Monad BaseParser where
    return = pure
    p &gt;&gt;= f = BaseParser $ \s -&gt;
        let (s', a) = runBaseParser p s
         in runBaseParser (f a) s'
</code></pre>
<p>大功告成，我們用了20多行代碼就搞定了這個<code>BaseParser</code>。</p>
<h2>錯誤處理？</h2>
<p><code>BaseParser</code> 定義沒有提到錯誤處理，但這並不意味著<code>BaseParser</code>不能處理錯誤。只需要加上<code>ExceptT</code>這一Monad Transformer然後包裝成一個新類型即可。</p>
<pre><code class="language-haskell">{-# LANGUAGE GeneralizedNewtypeDeriving #-}
import Control.Monad.Except (ExceptT)

newtype Parser a = Parser (ExceptT String BaseParser a)
    deriving (Functor, Applicative, Monad)
</code></pre>
<p>這就是我們需要的所有代碼。</p>
<h2>組合「或」解析器</h2>
<p><code>Applicative</code> 和 <code>Monad</code> 允許我們將幾個解析器組合在一起，以便解析一個序列。但是&quot;垂直&quot;的組合呢？比如解析 <code>json</code> 格式的文本，我們可能想嘗試一起解析一個<strong>數字</strong>或<strong>字符串</strong>或<strong>數組</strong>。為了滿足這種要求，我們將為 <code>Parser</code> 引入一個新運算符<code>&lt;|&gt;</code>。</p>
<pre><code class="language-haskell">import Control.Monad.Except (ExceptT (ExceptT))
import Control.Monad.Trans.Except (runExceptT)

parser :: (String -&gt; (String, Either String a)) -&gt; Parser a
parser = Parser . ExceptT . BaseParser

runParser :: Parser a -&gt; String -&gt; (String, Either String a)
runParser (Parser p)= runBaseParser . runExceptT $ p

(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p1 &lt;|&gt; p2 = parser $ \s -&gt;
    case runParser p1 s of
        (_, Left _) -&gt; runParser p2 s
        a -&gt; a
</code></pre>
<h2>一些常用的Parser實現</h2>
<p>現在我們的解析器已經準備好解析任何東西了。我在這裡給出一些示例，同時也可以參考 <a href="https://github.com/TerenceNg03/Seml/">我的 Seml Github 倉庫</a>，實現了一個將 S 表達式解析為 XML的Parser。</p>
<h3>Char 解析器</h3>
<p>從一個只能解析一個字符的解析器開始。</p>
<pre><code class="language-haskell">charP :: (Char -&gt; Bool) -&gt; Parser Char
charP f = parser $ \s -&gt;
    case s of
        (x : xs)
            | f x -&gt; (xs, Right x)
            | otherwise -&gt; (s, Left &quot;Invalid Char&quot;&quot;)
        [] -&gt; (s, Left &quot;Eof Error&quot;)

isP :: Char -&gt; Parser Char
isP c = charP (== c)
</code></pre>
<h3>重複Parser</h3>
<p>現在我們想解析一個標識符。為此，我們需要重復 <code>charP</code> <code>n</code> 次。</p>
<pre><code class="language-haskell">import Control.Applicative (liftA2)
import Data.Char (isAlphaNum, isLetter)

someP :: Parser a -&gt; Parser [a]
someP p = liftA2 (:) p (manyP p)

-- Be careful here we do not want to stuck
-- on an empty string
manyP :: Parser a -&gt; Parser [a]
manyP p = terminateP &lt;|&gt; someP p &lt;|&gt; return []

terminateP :: Parser [a]
terminateP = parser $ \s -&gt;
    case s of
        [] -&gt; ([], Right [])
        _ -&gt; (s, Left &quot;&quot;)

-- | Repeat a parser
repeatP :: Parser a -&gt; Parser [a]
repeatP = manyP

-- | Recognize an identifier
identP :: Parser String
identP = liftA2 (:) (charP isLetter) $
    repeatP $ charP isAlphaNum
</code></pre>
<p>請注意，即使我們在這裡處理了空字符串，<strong>重復接受空字符串的Parser</strong>仍會導致<strong>無限循環</strong>。</p>
<h3>between Parser</h3>
<p>好的，我們可以解析一個標識符。但是解析帶引號的字符串怎麼辦？</p>
<pre><code class="language-haskell">-- | Parse something between other things
betweenP :: Parser l -&gt; Parser r -&gt; Parser mid -&gt; Parser mid
betweenP l r m = l *&gt; m &lt;* r

-- Simplified escape handling, we just return what ever 
-- character that is escaped and do not translate 
-- `\n` into newline or etc.
escapeSP :: Parser Char
escapeSP = isP '\\' *&gt; charP (const True)

quotedP :: Parser String
quotedP =
    let ssP = repeatP (escapeSP &lt;|&gt; charP (/= '\''))
        dsP = repeatP (escapeSP &lt;|&gt; charP (/= '&quot;'))
        singleP = betweenP (isP '\'') (isP '\'') ssP
</code></pre>
<h3>分隔符Parser</h3>
<p>假設有一個由一些隨機空格分隔的單詞列表。我們該如何解析這些東西呢？</p>
<pre><code class="language-haskell">-- | Repeat parser with separator 
sepByP :: Parser s -&gt; Parser a -&gt; Parser [a]
sepByP ps pa = liftA2 (:) pa
</code></pre>

        </div>
        <div class="footer-container">
            <div class="footer">
                <div class="quote">
                    <p>
                        永遠太遠 · 無謂太早 · 分對或錯
                    </p>
                </div>
                <div class="footer-inner" id="About">
                    <div class="copyright">
                        Original Photos &amp; Contents
                    </div>
                    <div class="copyright">
                        Copyright ©2021-2023 TerenceNg  All Rights Reserved.
                    </div>
                </div>
                <div class="contact-me">
                    <a href="https://github.com/TerenceNg03">
                        Github Profile
                    </a>
                    |
                    <a href="stoicism03@gmail.com">
                        Contact Me
                    </a>
                </div>
            </div>
        </div>
    </body>
</html>
